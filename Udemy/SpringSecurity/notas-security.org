parei em: assistir novamente a aula do 2. **`http.exceptionHandling()`**:
* erro
O simples fato de declarar qualquer uma das 2 dependencies e não no application.properties abaixo gera o erro de "** erro gerado"

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>


Obs importante: ao  atualizar o pom.xml, não esquecer de fazer o reload dos módulos.

** erro gerado

***************************
APPLICATION FAILED TO START
***************************

Description:

Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.

Reason: Failed to determine a suitable driver class


Action:

Consider the following:
	If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.
	If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).

* Porque proteção CSRF bloqueia
Em métodos GET não ocorre bloqueio de CSRF, mas ao tentar fazer um POST e afins (ex: PUT, DELETE), sim (erro HttpStatus 403: Forbidden).

Para desabilita-lo precisamos de adicionar:
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
	(continua o código...)

* versões/configurações usadas no curso
- Spring Boot 3.3.0
- Maven
- Java 21
- Dependences
	- Spring Web
	- Spring Boot DevTools (para reexecutar o projeto automaticamente)
	- Spring Security
Na seção 4 são adicionados:
	- JDBC API
	- MySQL Driver
	- Spring Data JPA
	- Lombok (adiciona na aula 32. Obs: é preciso adicionar o plugin do Lombok tb pra ele aparecer legal no IntelliJ)
Obs: o projeto da Udemy printa as queries no formato Hibernate

* Lombok  (para ver os métodos criados pelo lombok, usar o amostrar  métodos do IntelliJ)
Alt + 7 
  e
Ctrl + F12

* Senha default (quando não é definida nenhuma senha)
Ao adicionar a dependência do Spring Security ao projeto, por padrão passa a pedir senha. Nesse caso:
- usuário: user
- senha: aparece printada no console na hora que sobe o microsserviço
* definindo usuário/senha: MODO #01
** preenchendo application.properties
spring.security.user.name = eazybytes
spring.security.user.password = 12345
* Mostrando mensagens de TRACE no console do IntelliJ durante o processamento de uma biblioteca
Adicione a seguinte linha ao seu arquivo application.properties:
logging.level.org.springframework.security=TRACE

Usando application.yml: Se você estiver usando um arquivo application.yml, adicione a seguinte configuração:
logging:
  level:
    org.springframework.security: TRACE

Aparentemente esse recurso pode ser aplicado a outras bibliotecas.
* Processo
uma vez feito o login, a cada nova requisição: não é mais feita requisição ao Authentication Manager, o Security Context diz que já está logado.
* Cookies
** No DevTools
Ir na aba "Application", na seção "Storage" há o item "Cookies".
É possível que haja um elemento  de nome "JSESSIONID" com um hash... esse hash é passado para o Security Context - ele avalia se é válido.
* Configurando as permissões no Bean
** permitAll()
@Configuration
public class ProjectSecurityConfig {

    @Bean
    SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {

        http.authorizeHttpRequests((requests) -> requests.anyRequest().permitAll())
            .formLogin(Customizer.withDefaults())
            .httpBasic(Customizer.withDefaults());
        
        return http.build();
    }
}
** denyAll()
@Configuration
public class ProjectSecurityConfig {

    @Bean
    SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {

        http.authorizeHttpRequests((requests) -> requests.anyRequest().denyAll())
            .formLogin(Customizer.withDefaults())
            .httpBasic(Customizer.withDefaults());
        
        return http.build();
    }
}
** configurado para permitir alguns e autenticar outros
@Configuration
public class ProjectSecurityConfig {

    @Bean
    SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {

        http.authorizeHttpRequests()
                        .requestMatchers("/myAccount","/myBalance","/myLoans","/myCards").authenticated()
                        .requestMatchers("/notices","/contact").permitAll()
                .and().formLogin()
                .and().httpBasic();
        return http.build();
    }
}
** configurando para desabilitar o formulariozinho de autenticação 
Com isso é mostrado um formulário próprio do browser
http.authorizeHttpRequests((requests) -> requests
    .requestMatchers("/myAccount", "/myBalance", "/myLoans", "/myCards").authenticated()
    .requestMatchers("/notices", "/contact", "/error").permitAll())
    .formLogin(flc -> flc.disable())  //*************************
    .httpBasic(Customizer.withDefaults());
** configurando para desabilitar a página do formulariozinho (HTML) de autenticação 
Com isso não aparece  forma nenhuma de autenticação via web. Pode-se usar a autenticação via Postman do tópico abaixo
http.authorizeHttpRequests((requests) -> requests
    .requestMatchers("/myAccount", "/myBalance", "/myLoans", "/myCards").authenticated()
    .requestMatchers("/notices", "/contact", "/error").permitAll())
    .formLogin(Customizer.withDefaults()) //No video do curso o professor deixou aqui  como no tópico acima:    .formLogin(flc -> flc.disable())
    .httpBasic(hbc -> hbc.disable()); //**************

* Autenticando via postman
Na guia "Authorization" escolhe-se no "Auth Type": "Basic Auth" e digita-se o "Username" e "Password"
* ver atualizações do Spring Security
https://dev.to/wldomiciano/metodos-obsoletos-da-httpsecurity-no-spring-security-61-5033?fbclid=IwAR23WQOlLKOJS8XHGQu5wqkZhW1qjldYOnksk2WIkIWJUyp7ERLyDihm0YU
* Formas de armazenar usuários/credenciais
** Armazenando usuários na memória (Seção 3)
*** usando senhas como plain text
dentro de: public class ProjectSecurityConfig { 

@Bean
public UserDetailsService userDetailsService() {

    UserDetails user = User.withUsername("user").password("{noop}12345").authorities("read").build();
    UserDetails admin = User.withUsername("admin").password("{noop}54321").authorities("admin").build();

    return new InMemoryUserDetailsManager(user, admin);
}

Obs: apesar de as senhas estarem como: {noop}12345  e  {noop}54321, as senhas são 12345 e 54321. O "{noop}" é usado para especificar que não haverá nenhuma encoder no password, mas entendê-lo como plain text.
*** usando senhas com encodação padrão do spring (BCrypt)
criar o hash da senha em: bcrypt-generator.com

dentro de: public class ProjectSecurityConfig { 

@Bean
public UserDetailsService userDetailsService() {

    UserDetails user = User.withUsername("user").password("{noop}12345").authorities("read").build(); //*** conforme tópico acima: a senha é 12345, mas tem que colocar o "{noop}" pra dizer que não está encodada
    UserDetails admin = User.withUsername("admin")
        .password("{bcrypt}$2a$12$8A3r8ysU5CFsR1IbyMI8O.PoaVXKcC0xExHQ/.B3at4XfkkYTI.yO")  //******* a senha era 54321, que após passar peo site bcrypt-generator.com ficou o que vem após o "{bcrypt}". É preciso colocar o {bcrypt} pra o Spring saber que é esse o tipo de encodação
        .authorities("admin").build();

    return new InMemoryUserDetailsManager(user, admin);
}

@Bean
public PasswordEncoder passwordEncoder() {
    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
/*
Dentro desse método é declarado:
		String encodingId = "bcrypt";
Pro: Ou seja: A encodação BCryot é recomendada mesmo para projetos em produção. Outro ponto: se não for passado o prefixo "{noop}" antes da senha no User.withUsername("user").password("{noop}12345").authorities("read").build() ele considera que a senha é por padrão BCrypt 
*/
}

*** exigindo que o usuário crie senhas fortes (Aula 24)
dentro de: public class ProjectSecurityConfig { 	
    /**
     * From Spring Security 6.3 version
     * @return
     */
    @Bean
    public CompromisedPasswordChecker compromisedPasswordChecker() {
        return new HaveIBeenPwnedRestApiPasswordChecker();
    }
* UserDetailsManager x UserDetailsService
 Which of the following statements about the UserDetailsManager interface in Spring Security is correct?
R: UserDetailsService provides methods for creating, updating, and deleting user accounts

Which of the following statements about the UserDetailsService interface in Spring Security is correct?
R: UserDetailsService loads user-specific data during authentication
* Definindo Banco de Dados
** JDBC
Após adicionarmos as bibliotecas do banco de dados, e ao definirmos em application.properties:
spring.datasource.url=jdbc:mysql://${DATABASE_HOST:localhost}:${DATABASE_PORT:3306}/${DATABASE_NAME:eazybank}
spring.datasource.username=${DATABASE_USERNAME:root}
spring.datasource.password=${DATABASE_PASSWORD:root}
spring.jpa.show-sql=${JPA_SHOW_SQL:true}
spring.jpa.properties.hibernate.format_sql=${HIBERNATE_FORMAT_SQL:true}

*** Quando declaramos em ProjectSecurityConfig.java:
    @Bean
    public UserDetailsService userDetailsService(DataSource dataSource) {
        return new JdbcUserDetailsManager(dataSource);
    }

O Spring entende que esse campo "DataSource dataSource" é o do JDBC declarado em application.properties.

Obs: adicionalmente, nesse arquivo precisamos do 
    @Bean
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }

//Já esse abaixo, acredito ser opcional:
    /**
     * From Spring Security 6.3 version
     * @return
     */
    @Bean
    public CompromisedPasswordChecker compromisedPasswordChecker() {
        return new HaveIBeenPwnedRestApiPasswordChecker();
    }
** JPA
*** Para definir um sistema que autentica via JPA é preciso comentar as linhas dentro do config
//    @Bean
//    public UserDetailsService userDetailsService(DataSource dataSource) {
//        return new JdbcUserDetailsManager(dataSource);
//    }
*** Para definir um sistema que autentica via JPA é preciso declarar as linhas

@Service
@RequiredArgsConstructor
public class TimeFlowUserDetailsService implements UserDetailsService {

    private final CustomerRepository customerRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Customer customer = customerRepository.findByEmail(username).orElseThrow(() -> new
                UsernameNotFoundException("User details not found for the user: " + username));
        List<GrantedAuthority> authorities = List.of(new SimpleGrantedAuthority(customer.getRole()));
        return new User(customer.getEmail(), customer.getPwd(), authorities);
    }
}


* Encoding x Encryption x Hashing
** **Encoding** (com notas de Pro do curso)
- Encoding is defined as the process of converting data from one form to another and has nothing to do with cryptography.
- It involves no secret and completely reversible.
- Encoding can't be used for securing data. Below are the various publicly available algorithms used for encoding.

    Ex: ASCII, BASE64, UNICODE

Pro: para encodar um conteúdo em base64 (por exemplo) podemos usar o aplicativo de terminal openssl:
 openssl base64 -in inputToEncode.txt -out outputEncoded.txt

Para decodar:
 openssl base64 -d -in outputEncoded.txt -out fraseDecoded.txt
** **Encryption** (com notas de Pro do curso): Não é recomendado para senhas!
- Encryption is defined as the process of transforming data in such a way that guarantees confidentiality.
- To achieve confidentiality, encryption requires the use of a secret which, in cryptographic terms, we call a "key".
- Encryption can be reversible by using decryption with the help of the "key". As long as the "key" is confidential, encryption can be considered as secured.

O texto encriptado chama: "Cipher Text"
Pro: Existem 2 tipos: simétrica e  assimétrica
*** simétrica
a mesma secret key é usada tanto para encriptar como  decriptar. Ou seja: é preciso cuidado redobrado para proteger a secret key.

caso de uso: Buckets S3 da AWS (Com opção de o usuário fornecer a key)
*** assimétrica
Há 2 chaves (secret keys):
**** public key
usada para encriptar
é usada tanto para encriptar 
**** private key
usada para decriptar
**** descrição
Here is the transcription of the text from the image you provided:

**Asymmetric encryption** - Asymmetric encryption functions like a unique lock with two distinct keys: one for locking (encrypting) and one for unlocking (decrypting). You keep the private key, which unlocks the message, secure with you, while freely distributing the public key to anyone who wants to send you an encrypted message. They use this public key to encrypt their message, and only you can decrypt it using your private key. This system ensures secure communication, as it relies on a pair of keys: a **public key for encryption and a private key for decryption**.

Como alguém pode hackear e obter as chaves, essa pessoa pode ter os dados decriptados - por isso  encriptação não é recomendada para senhas.
**** exemplo de caso prático de encriptação/decriptação
comando para encriptar:
openssl enc -aes-256-cbc -pass pass:12345 -pbkdf2 -in plainInput.txt -out encryptOutput.txt -base64
onde:
	-aes-256-cbc = algoritmo escolhido para encriptação 
	12345 = secret key
	-pbkdf2 = recurso usado para trabalhar com a secret key para tornar mais difícil ainda a decriptação
	-base64 = torna a saída gerada em formato legível para leitura para o usuário visualizar

comando para decriptar:
openssl enc -aes-256-cbc -base64 -pass pass:12345 -d -pbkdf2 -in encryptOutput.txt -out decriptedOutput.txt
onde:
	-d: pede para decriptar
	(idem como acima para demais parâmetros)
** **Hashing** (Usado para senhas)

- In hashing, data is converted to the hash value using some hashing function.
- Data once hashed is non-reversible. One cannot determine the original data from a hash value generated.
- Given some arbitrary data along with the output of a hashing algorithm, one can verify whether this data matches the original input data without needing to see the original data.

Pro: Não é reversível.
A saída de hash é chamada de "digest" ou um "HASH".
As saídas geradas possuem tamanho fixo, conforme o tipo. Exemplo: Para o uso via SHA-256, a saída sempre possuí 256 bits, idependentemente o tamanho da entrada.
*** caso prático de gerar hash
echo -n "meu texto a passar para hash" | openssl dgst -sha256
saída: dde7534e8b2e30b18a3ab3c188eabeeb927dc7d0fad2cc87b08568a0ec577aee
onde -sha256 é o algorítmo de hash
Obs: comando para testar se o hash sha-256 de um download é igual ao do servidor:

	openssl dgst -sha256 nomeArquivo.zip

a saída pode ser copiada e rodar um CTRL+F no browser para comparar.
*** recursos para dificultar a descoberta do valor da senha
**** Usando "salt value" - geração randômica adicionada à senha (esse salt value fica salvo também no banco de dados). Só não tem valor se o hacker consegue adquirir esse salt value do banco - nesse caso precisamos do recurso abaixo.

**1.** To prevent rainbow table attacks, **salts** are commonly used. Salts are random values that are unique for each user and are made public. The salt value is stored as part of the resulting hash itself. Specifically, the salt is included in the hash string along with the actual hashed password. The salt is typically stored at the beginning of the hash string and is used during the password verification process to generate the same hash again for comparison. Since each user has a unique hash function, attackers can't precompute large tables of passwords (rainbow tables) to test against the entire database of stolen password hashes.

**** Fazendo o hashing process ser devagar (ex: usando BCrypt que usa CPU e memória, demorando +- 1 segundo para "hashear" uma String de 8 caracteres (com números, letras, símbolos especiais), o que o  hacker usando dicionário ou geração sequência de possíveis valores levaria 10 anos para descobrir uma senha).
**Plain text password + Random salt value + Hashing Algo = Protection from Rainbow attacks**

**2.** Brute force attacks issue can be solved with password hashes, which are designed to be slow. The normal hashing process is quite fast, due to which attackers can do the trial and error by trying any number of plain passwords to check against hashed passwords. We can make attacker life tough by using password hashing algorithms like **PBKDF2**, **bcrypt**, **scrypt** and **Argon2**. These algorithms slow the hashing process and demand lots of CPU cost, memory cost.

These algorithms are specifically designed to slow down the hashing process, thereby increasing the time and resources required for an attacker to guess passwords. They achieve this by introducing additional computational costs, such as CPU and memory, into the hashing process. By making it more computationally expensive to hash passwords, these algorithms make brute force attacks less practical and deter attackers from attempting them.

**Spring Security provides industry recommended Password Encoders that are capable of generating random salt and leverage password hashing algorithms like bcrypt**.










** Observação a respeito de dizer que transformar uma senha em BCrypt é uma "encodação"
A imagem que você compartilhou menciona o **SCrypt** no contexto de um **PasswordEncoder**. Embora o nome da interface seja `PasswordEncoder`, a utilização do termo "encode" aqui pode ser confusa, porque em casos como **bcrypt** ou **SCrypt**, o processo é de **hasheamento**.

O Spring usa o termo **PasswordEncoder** por convenção, mas é importante entender que **o que está acontecendo não é uma encodação no sentido técnico usual (como em Base64 ou UTF-8), mas sim um processo de hasheamento**. Tanto o **bcrypt** quanto o **SCrypt** são algoritmos de hasheamento que fazem a transformação da senha em um hash seguro.

Esses algoritmos aplicam técnicas como "salt" e "cost factor" para garantir que os hashes gerados sejam únicos e difíceis de serem revertidos ou quebrados, mesmo em caso de ataque de força bruta.

Então, mesmo que o Spring use o termo "PasswordEncoder" na interface, o processo é, de fato, de **hasheamento** e não encodação. Essa convenção é apenas uma escolha de nome para a interface e não reflete o tipo de transformação dos dados.
* Authentication Provider
Podemos definir uma implementação para a autenticação via nome de usuário e senha, e outro por OAuth2, outro por xyz.
** DaoAuthenticationProvider
Quando um usuário tenta fazer login, o DaoAuthenticationProvider consulta o UserDetailsService para obter um objeto UserDetails correspondente ao nome de usuário fornecido.

Usamos o DaoAuthenticationProvider padrão apenas para o caso geral de autenticação. Se quisermos aplicar alguma regra de autenticação, por exemplo: se o usuário é do país X, ou se é maior de 18 anos, precisamos escrever o nosso provider personalizado.
** AuthenticationProvider
Methods inside AuthenticationProvider inteface:

1) The authenticate() method receives and returns authentication object. We can implement all our custom authentication logic inside authenticate() method.

2) The second method in the AuthenticationProvider interface is supports(Class<?> authentication). You'll implement this method to return true if the current AuthenticationProvider supports the type of the Authentication object provided.
** Escrevendo uma implementação do authenticate()

@Override
public Authentication authenticate(Authentication authentication) throws AuthenticationException {
    String username = authentication.getName();
    String pwd = authentication.getCredentials().toString();
    
    UserDetails userDetails = userDetailsService.loadUserByUsername(username);  // Aqui, como foi declarado 
									// que "class TimeflowUserDetailsService implements UserDetailsService"
									// vai ser executado o método loadUserByUsername dessa classe
    
    if (passwordEncoder.matches(pwd, userDetails.getPassword())) {

        // Fetch Age details and perform validation to check if age > 18

        return new UsernamePasswordAuthenticationToken(username, pwd, userDetails.getAuthorities());
    } else {
        throw new BadCredentialsException("Invalid password!");
    }
}

* Profiles
** application.properties 
São possíveis de serem declarados em application.properties como:

	spring.config.import = application-prod.properties, application-dev.properties, application-qa.properties 
	spring.profiles.active = default  //Aqui é possível escolher múltiplos profiles. Com "default" é escolhido o application.properties
						// mas poderia ser: spring.profiles.active = dev 
** application-prod.properties
precisamos dar o nome desses profiles específicos, como por exemplo com a linha:

	spring.config.activate.on-profile=prod

** verificar visualmente qual o profile em execução
na saída do console do carregamento do aplicativo, na segunda linha temos:
	18:59:30.374 INFO  [main] c.t.s.SecurityApplication - The following 1 profile is active: "default"

poderia ser
	19:00:37.280 INFO  [main] c.t.s.SecurityApplication - The following 1 profile is active: "dev"
ou qualquer outro escolhido em spring.profiles.active (exemplo: via configuração do VM Options:

	 -Dspring.profiles.active=prod

 ou via "Enviroment Variables" com:

	 SPRING_PROFILES_ACTIVE=prod  

sendo que podemos setar as "Enviroment Variables" via Jenkins, por linha de comando, através de Argumento de Ambiente do Docker, pela AWS, etc.
** Observação importante de quando desabilitamos as senhas
Quando desabilitamos as senhas, com qualquer senha o usuário loga, porém, é preciso que forneçamos um nome de usuário válido (para que sejam pegos os roles e referências de configurações específicas desse usuário).
** Especificando arquivos de configurações através de profiles 
*** Exemplo 1
@Component
@Profile("prod")
public class TimeflowProdUsernamePwdAuthenticationProvider implements AuthenticationProvider {

@Component
@RequiredArgsConstructor
@Profile("!prod")
public class TimeflowUsernamePwdAuthenticationProvider implements AuthenticationProvider {
*** Exemplo 2
@Configuration
@Profile("prod")
public class ProjectSecurityProdConfig {

@Configuration
@Profile("!prod")
public class ProjectSecurityConfig {

* HTTP e HTTPS
Por padrão o Spring permite tanto requisições HTTP como HTTPS.
Para impôr limitação é preciso adicionar no Bean uma chamada:
** Apenas HTTPS
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.requiresChannel(rcc -> rcc.anyRequest().requiresSecure()) // Only HTTPS
		...
** Apenas HTTP
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.requiresChannel(rcc -> rcc.anyRequest().requiresInsecure()) // Only HTTP
		...
* Lidando com exceções
If a client attempts to access a resource without authentication or proper authorization, they should be prompted to provide credentials to access the resource. This can be achieved by either redirecting the client to a login page in the user interface or by informing them about the situation through an API response.

Inside Spring Security authentication & authorization related exceptions are handled by `ExceptionTranslationFilter`.

Há 2 tipos de retornos de exceções no Spring Security:
** AuthenticationException (HttpStatus code 401 (HttpStatus = "Unauthorized"))
leads to **AuthenticationEntryPoint** via `ExceptionTranslationFilter`.
Diz: a pessoa que está fazendo a requisição não está autenticada.
*** AuthenticationEntryPoint
An AuthenticationEntryPoint in your Spring application serves as a handler for unauthenticated access attempts, determining how to respond when someone tries to access a part of your site or API without the authentication. Think of it as a gatekeeper in a party who decided what needs to be done if there is no invite. Similarly AuthenticationEntryPoint might redirect users to a login page or return an error message indicating that authentication is necessary.

Below is the definition of AuthenticationEntryPoint interface,

public interface AuthenticationEntryPoint {
    void commence(HttpServletRequest request, HttpServletResponse response,
                  AuthenticationException authException) throws IOException, ServletException;
}

LoginUrlAuthenticationEntryPoint, BasicAuthenticationEntryPoint are a few of the Spring Security provider implementations of AuthenticationEntryPoint interface that gets executed by default in case of AuthenticationException.
*** Defining Custom AuthenticationEntryPoint
Below are the snippets on how to define a Custom AuthenticationEntryPoint for the HTTP Basic login flow,

1) We need to create an implementation class using the `AuthenticationEntryPoint` interface & by overriding the `commence()` method. Inside the `commence()` method, we can build logic on what response to send back to clients based on our requirements.

#+BEGIN_SRC java
public class CustomBasicAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException, ServletException {
        // Populate dynamic values
        LocalDateTime currentTimeStamp = LocalDateTime.now();
        String message = (authException != null && authException.getMessage() != null) ? authException.getMessage()
                : "Unauthorized";
        String path = request.getRequestURI();
        response.setHeader("timeflow-error-reason", "Authentication failed");
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType("application/json;charset=UTF-8");
        // Construct the JSON response
        String jsonResponse =
                String.format("{\"timestamp\": \"%s\", \"status\": %d, \"error\": \"%s\", \"message\": \"%s\", \"path\": \"%s\"}",
                        currentTimeStamp, HttpStatus.UNAUTHORIZED.value(), HttpStatus.UNAUTHORIZED.getReasonPhrase(),
                        message, path);
        response.getWriter().write(jsonResponse);
    }

#+END_SRC java

Obs: para implementar o passo abaixo é preciso remover: .httpBasic(Customizer.withDefaults());

2) The `CustomBasicAuthenticationEntryPoint` created in the above step can be configured for the `httpBasic` flow like shown below:

        http.httpBasic(hbc -> hbc.authenticationEntryPoint(new CustomBasicAuthenticationEntryPoint()));

**** TODO declarando http.exceptionHandling()
(AP: Não consegui habilitar o login declarando apenas a exceptionHandling(). Ver pergunta do tópico abaixo.)

We can also configure custom AuthenticationEntryPoint globally that is common for all the login types using exceptionHandling configurations. Below is the snippet of the same,

        http.exceptionHandling(ehc -> ehc.authenticationEntryPoint(new CustomBasicAuthenticationEntryPoint())); //  It is a 
													// Global Config

A implementação via exceptionHandling é mais completa, pois trata outras formas em que podem ocorrer o erro 401. Essa deve ser usada em grandes projetos que vão para produção.
Obs: essa exceptionHandling() desabilita a configuração: http.formLogin(Customizer.withDefaults()); 
em vista que a mesma passaria a ser feita por um provedor do frontend através de configurações, como por exemplo;
  	http.formLogin(flc -> flc.loginPage(...));

***** ChatGPT: essas 2 configurações (http.httpBasic(hbc.authenticationEntryPoint()) e http.exceptionHandling(ehc -> ehc.authenticationEntryPoint()) são excludentes, ou é esperado que se declare a primeira sempre que declaro a segunda? 
Essas duas configurações no Spring Security não são excludentes, mas elas têm finalidades ligeiramente diferentes e podem ser usadas juntas, dependendo do que você deseja configurar.

### Diferença entre as duas configurações:

1. **`http.httpBasic()`**:
   - Configura especificamente a autenticação básica HTTP. Essa configuração define como lidar com exceções **somente para requisições que utilizam o fluxo de autenticação básica**.
   - A chamada `http.httpBasic(hbc -> hbc.authenticationEntryPoint(new CustomBasicAuthenticationEntryPoint()));` define um ponto de entrada personalizado **apenas** para requisições que tentam se autenticar com HTTP Basic. Se uma requisição falhar nesse contexto, o `CustomBasicAuthenticationEntryPoint` será usado para lidar com a exceção.

2. **`http.exceptionHandling()`**:
   - Configura o tratamento de exceções para **todas as formas de autenticação**, não se limitando apenas ao HTTP Basic. Isso inclui outros tipos de autenticação, como **JWT, OAuth, Form Login, etc.**
   - A chamada `http.exceptionHandling(ehc -> ehc.authenticationEntryPoint(new CustomBasicAuthenticationEntryPoint()));` define um `AuthenticationEntryPoint` global que será usado para lidar com exceções relacionadas à autenticação (como falhas de login ou permissões) **em qualquer fluxo de autenticação**.

### Uso combinado:

- Se você está configurando **apenas o HTTP Basic**, geralmente basta usar a primeira configuração (`http.httpBasic()`).
- Se você quer definir um tratamento de exceções para **outros tipos de autenticação** ou quer ter uma configuração **global** para o tratamento de exceções, a segunda (`http.exceptionHandling()`) é mais apropriada.

### Quando usar ambas?

- Se a sua aplicação utiliza **diferentes métodos de autenticação** (por exemplo, HTTP Basic e JWT), você pode precisar usar ambas as configurações. Nesse caso, você estaria configurando um tratamento específico para o fluxo de autenticação HTTP Basic e outro tratamento **global** para os demais métodos de autenticação.

### Exemplo de uso:


http
    .httpBasic(hbc -> hbc.authenticationEntryPoint(new CustomBasicAuthenticationEntryPoint())) // Apenas para HTTP Basic
    .exceptionHandling(ehc -> ehc.authenticationEntryPoint(new GlobalAuthenticationEntryPoint())); // Para qualquer outro fluxo de autenticação


Aqui, você define um ponto de entrada personalizado para falhas de autenticação HTTP Basic e outro ponto de entrada para lidar com falhas em **todos os outros** métodos de autenticação.

### Conclusão:

- **Não são excludentes**. Você pode declarar ambas as configurações se precisar de um ponto de entrada diferente para fluxos de autenticação específicos (como HTTP Basic) e outro para tratamento global de exceções de autenticação.
- Se a sua aplicação usa **apenas HTTP Basic**, você pode simplesmente usar a configuração `http.httpBasic()`.
- Se a sua aplicação usa vários métodos de autenticação, você pode usar ambos, ou somente `http.exceptionHandling()` se quiser uma configuração global.

** AccessDeniedException (HttpStatus code 403)
leads to **AccessDeniedHandler** via `ExceptionTranslationFilter`.
Diz: Forbidden Error (o usuário está autenticado, mas não tem privilégio (ou `role`) para fazer a requisição).

Pode ser obtido ao tentar, autenticado, acessar um endpoint que não existe.
*** Código a ser adicionado no ProjectSecurityConfig.java
        http.exceptionHandling(ehc -> ehc.accessDeniedHandler(new CustomAccessDeniedHandler()));
        // In the example above, when a 403 error occurs during browser access, a JSON response is shown.
        // Using the example below, we can specify a URL to redirect the user to when they attempt to access a page without
        // the necessary permissions.
        //http.exceptionHandling(ehc -> ehc.accessDeniedHandler(new CustomAccessDeniedHandler()).accessDeniedPage("/denied"));
*** Exemplo de classe handler
package com.timeflowsystem.security.exceptionhandling;
...
public class CustomAccessDeniedHandler implements AccessDeniedHandler {
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
            AccessDeniedException accessDeniedException) throws IOException, ServletException {
        // Populate dynamic values
        LocalDateTime currentTimeStamp = LocalDateTime.now();
        String message = (accessDeniedException != null && accessDeniedException.getMessage() != null) ?
                accessDeniedException.getMessage() : "Authorization failed";
        String path = request.getRequestURI();
        response.setHeader("timeflow-denied-reason", "Authorization failed");
        response.setStatus(HttpStatus.FORBIDDEN.value());
        response.setContentType("application/json;charset=UTF-8");
        // Construct the JSON response
        String jsonResponse =
                String.format("{\"timestamp\": \"%s\", \"status\": %d, \"error\": \"%s\", \"message\": \"%s\", \"path\": \"%s\"}",
                        currentTimeStamp, HttpStatus.FORBIDDEN.value(), HttpStatus.FORBIDDEN.getReasonPhrase(),
                        message, path);
        response.getWriter().write(jsonResponse);
    }
}

* Sessions Management in Spring Security
** Handling Invalid Session
Using the below config, the user can be redirected to the given URL when an invalid session is detected,

http.sessionManagement(sessionConfig -> sessionConfig.invalidSessionUrl("/invalidSession"))

Obs: lembrar de adicionar, nesse caso, dentro da lista de endpoints de acesso permitidos o endpoint da página que será exibida quando a seção expirar:
	.requestMatchers("/invalidSession").permitAll()
** Session Timeout
With the help of the below property, we can configure what is the idle time after which the Spring Security created session should be expired. 20m indicates 20 minutes

Adicionar no application.properties:
	server.servlet.session.timeout=20m

Por padrão, o tempo de timeout do spring é de 30 minutos.
Obs1: se não fornecida a unidade (no exemplo acima foi de minutos ("m"), o Spring subtende em segundos)
Obs2: O Spring não deixa atribuir timeout menor que 2 minutos.
Obs3: é requerida inativadade para invalidar a seção, ou seja, enquanto houver acessos, o tempo de timeout é resetado a cada nova requisição.

** Concurrent Session Control
We can control the maximum sessions allowed for a user and what should happen in the case of invalid session due to too many sessions for the current user,

http.sessionManagement(sessionConfig -> sessionConfig.maximumSessions(1).maxSessionsPreventsLogin(true)
        .expiredUrl("/expiredSession"))

* Dicas de cursos
** Java  das Ruas
https://www.youtube.com/watch?v=N4cwmvjPj8c
* JWT
JSON Web Tokens
Prode-se dizer: "jot tokens" (pronúncioa: "jót")

é feito sempre o repasse do token do backend pro front, e do front pro back, e do back pro front, e ...
** composto por 3 partes
pode ser gerado pelo site:

	http://jwt.io

3 partes sepadas por "."
*** Primeira é o Header
we store metadata/info related to the token. If we chose to sign the token, the header contains the name of the algorithm that generates the signature.

**Exemplo de cabeçalho:**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
que é codificada em base64
*** Segunda é o Payload
- **In the body**, we can store details related to user, roles, etc., which can be used later for AuthN and AuthZ. Though there is no such limitation on what we can send and how much we can send in the body, but we should put our best efforts to keep it as light as possible.

**Exemplo de corpo:**
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```
que é codificada em base64
*** Terceira é o Signature (opcional)


```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
**Codificado em Base64:**
`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`

---

**Parte inferior:**

- **In the body**, we can store details related to user, roles, etc., which can be used later for AuthN and AuthZ. Though there is no such limitation on what we can send and how much we can send in the body, but we should p
**Exemplo de corpo:**
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```
**Codificado em Base64:**
`eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ`

---

Se precisar de mais informações sobre JWT ou como funciona, posso ajudar a esclarecer mais!


- This part can be optional if the party that you share the JWT token with is internal and someone who you can trust but not open in the web.
  
- But if you are sharing this token to the client applications which will be used by all the users in the open web then we need to make sure that no one changed the header and body values like Authorities, username, etc.

- To make sure that no one tampered the data on the network, we can send the signature of the content when initially the token is generated. To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.

- For example if you want to use the HMAC SHA256 algorithm (**Obs: esse algorítmo é de hasheamento**), the signature will be created in the following way:

		HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)

- The signature is used to verify the message wasn’t changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is.

Obs: A chave privada (secret) fica salva no backend.

Se por exemplo um hacker obter o header e o payload, e modificar o profile/role do payload para um com todas permissões, o servidor que faz a autorização, ao verificar a parte signature do jwt enviado pelo cliente (que é composto pelo header+payload+secret) verá que o resultado não confere com o hash da signature gerado nele para esses mesmos valores de header e payload, uma vez que usando a key secret obteve um hash da signature diferente.

No site http://jwt.io pode-se alterar no campo da esquerda os valores da encodação da base64 do header e do payload, o que aparecerá o valor correspondente do header/payload/sigature na direita - e se os valores HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret) não conferirem com o valor da signature obtem-se a label da página "Invalid Signature".







* commit messages 
//copilot:
A commit message is a message that is associated with a specific change made to a file in a repository. It is a way to communicate to other developers why a change was made, what the change was, and how it was made. A good commit message is clear, concise, and informative. It should explain the purpose of the change, the motivation behind it, and any relevant details about how the change was implemented. A commit message should also be written in the imperative mood, meaning it should describe what the change does, not what it did. For example, "Add feature X" is a good commit message, while "Added feature X" is not as clear. A commit message is an important part of the development process because it helps other developers understand the history of a project and the reasoning behind specific changes. It also helps with code reviews, debugging, and tracking down issues in the future.
